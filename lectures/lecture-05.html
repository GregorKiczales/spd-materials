<!DOCTYPE html>
<html>
  <HEAD>
    <LINK href="../spd-style.css" rel="stylesheet" type="text/css">
  </HEAD>
  
  <body>

    <p>[<a href="index.html">Index of Lectures</a>]</p>

    <p>
      [
      <a href="lecture-01.html">L01</a>
      <a href="lecture-02.html">L02</a>
      <a href="lecture-03.html">L03</a>
      <a href="lecture-04.html">L04</a>
      L05
      <a href="lecture-06.html">L06</a>
      <a href="lecture-07.html">L07</a>
      <a href="lecture-08.html">L08</a>
      <a href="lecture-09.html">L09</a>
      <a href="lecture-10.html">L10</a>
      <a href="lecture-11.html">L11</a>
      <a href="lecture-12.html">L12</a>
      <a href="lecture-13.html">L13</a>
      <a href="lecture-14.html">L14</a>
      <a href="lecture-15.html">L15</a>
      <a href="lecture-16.html">L16</a>
      <a href="lecture-17.html">L17</a>
      <a href="lecture-18.html">L18</a>
      <a href="lecture-19.html">L19</a>
      <a href="lecture-20.html">L20</a>
      <a href="lecture-21.html">L21</a>
      <a href="lecture-22.html">L22</a>
      ]
    </p>
    
    <h2>Lecture 05</h2>
    
    <h3>Before Lecture</h3>
    
    <p>You are now expected to be able to solve problems from the
      entirety of module 3a and the first four sections of 3b Compound
      Data. That is Module Overview, define-struct, Compound Data
      definitions and the Practice problems as you need to.</p>
    
    <h3>During Lecture</h3>

    <p>Writing a new program from scratch is fun, but programmers
      actually spend most of their time improving existing programs.
      Remember, any program that someone actually uses constantly
      requires revisions&ndash;to fix existing functionality, to add new
      functionality, or just to adapt to changes in surrounding
      programs.  You can revise existing programs reliably by following
      the same systematic design process used to develop them in the
      first place.  (Or by imposing a systematic revision process onto a
      clearly unsystematically designed program, but that is beyond
      scope for now.)</p>

    <p>By the end of the lecture&ndash;including the post-lecture work&ndash;you should be able to:</p>

    <ul>
      <li>Identify domain information that should be represented as
	compound data.</li>
      <li>Design a world program using compound data.</li>
      <li>Systematically revise an existing world program design to
	use a world state data definition and to add new functionality.</li>
    </ul>
	
    <p>In this lecture we will continue working on the spider world
      program. Here are the starters for today:</p>

    <ul>
      <li><a href="m03-compound-spider-starter.rkt">m03-compound-spider-starter.rkt</a></li>
      <li><a href="m03-compound-spider-v1.rkt">m03-compound-spider-v1.rkt</a></li>
      <li><a href="m03-compound-spider-v2.rkt">m03-compound-spider-v2.rkt</a></li>
    </ul>
	
    
    <h3>After Lecture</h3>


    <p>Today was the most difficult work we have done -
    congratulations! The design problem we worked through used pretty
    much every single thing we have covered so far in the course: all
    the recipes, big-bang, compound-data, revising an existing
    program. Everything!</p>

    <p>If it felt like a lot that's because it was a lot.</p>

    <p>Here are the solutions for this lecture:</p>

    <ul>
      <li><a href="m03-compound-spider-solution.rkt">m03-compound-spider-solution.rkt</a></li>
    </ul>

    <p>We started with a working world program, changed the
      requirements so that it needed a compound world state definition,
      and then had to revise and extend the program. The key is to trust
      the recipes to tell you where to focus your attention. Whenever
      you are unsure what to do, ask yourself "what recipe am I in, and
      what does it say I should do now?" Then you will not get confused
      about where to focus, and you can always focus on a small
      sub-problem.</p>


    <em><b>Trust the recipes.</b></em>

    <h4>To Review</h4>

    <p>To practice what you learned today we suggest you finish up (or
    rework!) the spider problem, starting from v2. When you are doing
    tock spend a long time on the examples.  Use paper to work them
    out!  In the key handler pay particular attention to the
    template. Rather than templating it from Spider, we template it
    according to KeyEvent using the large enumeration rule. The
    Improving a World Program&ndash;Add Key Handler section goes into this
    in some detail.</p>

    <p>A very good way to review this material--and really to review the
      entire course so far--is to work through the HtDW With Compound Data
      (aka Cowabunga) video. By work through we mean sit there with Dr Racket
      and a pad of paper and do the whole design in parallel with the video:
      start the video, watch a little, pause it and then try to get ahead of
      it on your own, restart it, etc. You won't get much out of just
      watching the video; in order to effectively practice, you must work
      through the problem on your own.</p>

    <p>If you had trouble with today's problem then you probably
      should repeat that entire design process before moving on to
      Cowabunga. You can go to instructor office hours or TA hours in
      the DLC (see the course web page) for additional help.</p>

    <p>Be sure to complete the before lecture section of <a href="lecture-06.html">Lecture 6</a> before that lecture.</p>

  </body>
</html>
