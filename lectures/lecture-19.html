<!DOCTYPE html>
<html>
  <HEAD>
    <LINK href="../spd-style.css" rel="stylesheet" type="text/css">
  </HEAD>
  
  <body>

    <p>[<a href="index.html">Index of Lectures</a>]</p>

    <p>
      [
      <a href="lecture-01.html">L01</a>
      <a href="lecture-02.html">L02</a>
      <a href="lecture-03.html">L03</a>
      <a href="lecture-04.html">L04</a>
      <a href="lecture-05.html">L05</a>
      <a href="lecture-06.html">L06</a>
      <a href="lecture-07.html">L07</a>
      <a href="lecture-08.html">L08</a>
      <a href="lecture-09.html">L09</a>
      <a href="lecture-10.html">L10</a>
      <a href="lecture-11.html">L11</a>
      <a href="lecture-12.html">L12</a>
      <a href="lecture-13.html">L13</a>
      <a href="lecture-14.html">L14</a>
      <a href="lecture-15.html">L15</a>
      <a href="lecture-16.html">L16</a>
      <a href="lecture-17.html">L17</a>
      <a href="lecture-18.html">L18</a>
      L19
      <a href="lecture-20.html">L20</a>
      <a href="lecture-21.html">L21</a>
      <a href="lecture-22.html">L22</a>
      <a href="lecture-23.html">L23</a>
      ]
    </p>
    
    <h2>Lecture 19&mdash;Tail Recursion 1</h2>
    
    <h3>Before Lecture</h3>
    
    <p>Before this lecture you should:</p>

    <ul>
      <li>Do an especially careful review of the two problems
      from <a href="lecture-18.html">lecture 18</a>.</li>
      <li>Before this lecture, please watch all the Tail Recursion
	videos and the Worklist Accumulators part 1 video.</li>
    </ul>

    
    <h3>During Lecture</h3>
    
    <p>The starters for this lecture are:</p>

    <ul>
      <li><a href="m10-reverse-starter.rkt">m10-reverse-starter.rkt</a></li>
      <li><a href="m10-tr-trees-starter.rkt">m10-tr-trees-starter.rkt</a></li>
    </ul>
	
    
    <h3>After Lecture</h3>

    <p>Tail recursion is different.  We arrange for the recursion to
      just keep calling, calling, calling until it finds a
      result. Notice that in the sequence? example we did
      in <a href="lecture-18.html">lecture 18</a>, we could easily
      have made that code tail recursive, by writing the recusive call
      using if instead of and:</p>

<pre>    
       (if (= (first lon) (+ 1 prev)) ;exploit (use)
           (sequence? (rest lon)
                      (first lon))
           false)</pre>

    <p>That puts the recursive call to sequence? in tail position and
      makes the function tail recursive. So tail recursive functions on
      lists are fairly straightforward.</p>

    <p>On trees on the other hand, tail recursion requires that we
      introduce a worklist, because when we go down one branch of a
      tree there are other branches that we need to come back to
      later.</p>

    <p>Be sure to finish the m10-tr-trees-starter.rkt file as soon as
      you can. That will help you lock in how to work with tail
      recursive tree templates, just like you once locked in how to work
      with recursive list templates.</p>

    <p>The solutions for this lecture are:</p>

    <ul>
      <li><a href="m10-reverse-solution.rkt">m10-reverse-solution.rkt</a></li>
      <li><a href="m10-tr-trees-solution.rkt">m10-tr-trees-solution.rkt</a></li>
    </ul>

      

    <p>Be sure to complete the before lecture section of <a href="lecture-20.html">Lecture 20</a> before that lecture.</p>

  </body>
</html>
