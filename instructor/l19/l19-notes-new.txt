



; start w/ fn-for-lox template


(define (fn-for-lox lox)
  (cond [(empty? lox) (...)]
        [else
         (... (first lox)
              (fn-for-lox (rest lox)))]))


; make it copy

(check-expect (fn-for-lox (list 1 2 3)) (list 1 2 3))

(define (fn-for-lox lox0)
  (cond [(empty? lox) empty]                ;base is empty
        [else
         (cons (first lox)                  ;combination is cons
               (fn-for-lox (rest lox)))]))

; but not TR

(define (fn-for-lox lox rsf)
  (cond [(empty? lox) empty]
        [else
         (fn-for-lox (rest lox))]))         ;tail recursive, but result always empty


; step 1 of acc refactoring

(define (rev lox0)                          ;setup for accumulator named 'rsf'
  ;; rsf is 
  (local [(define (fn-for-lox lox rsf)
            (cond [(empty? lox) empty]
                  [else
                   (fn-for-lox (rest lox)
                               ...rsf)]))]
    (fn-for-lox lox0 ...)))


(define (rev lox0)
  ;; rsf is ...
  (local [(define (fn-for-lox lox rsf)
            (cond [(empty? lox) empty]
                  [else
                   (fn-for-lox (rest lox)
                               (cons (first lox)      ;combination moves 
                                     rsf))]))]        ;into rsf update
    (fn-for-lox lox0 empty)))


(define (rev lox0)
  ;; rsf is (listof X); result so far
  ;;                    elements of lox0 seen so far in reverse order
  (local [(define (fn-for-lox lox rsf)
            (cond [(empty? lox) empty]
                  [else
                   (fn-for-lox (rest lox)
                               (cons (first lox)      ;combination moves 
                                     rsf))]))]        ;into rsf update
    (fn-for-lox lox0 empty)))









(define (fn-for-tree t n)
  (local [(define (fn-for-t t)
            (local [(define name (node-name t))  ;unpack the fields
                    (define subs (node-subs t))] ;for convenience
              
              (if (string=? name n)
                  t
                  (fn-for-lot subs))))
          
          (define (fn-for-lot lot)
            (cond [(empty? lot) false]
                  [else
                   (local [(define try (fn-for-t (first lot)))]
                     (if (not (false? try))
                         try
                         (fn-for-lot (rest lot))))]))]
    
    (fn-for-t t)))


(define (fn-for-tree t n)
  (local [(define (fn-for-t t tree-wl
            (local [(define name (node-name t))  ;unpack the fields
                    (define subs (node-subs t))] ;for convenience
              
              (if (string=? name n)
                  t
                  (fn-for-lot (append subs tree-wl)))))
          
          (define (fn-for-lot tree-wl)
            (cond [(empty? lot) false]
                  [else
                   (fn-for-t (first tree-wl) (if (not ???))) ;NO
                   
                   (fn-for-t (first tree-wl)

                             (rest tree-wl))]) ;remaining trees to visit, if (first lot fails)
            ;                               ;no combination, so no rsf
    
    (fn-for-t t)))
         
