
intro (3 slides)

- start adding path
  - motivate with M4
  - add up, left, demo that it hangs, ask why
  - develop idea of adding path (3 slides)
  - add [(member p path) false]
  - then class works on adding rest <10 mins

- come back and take contributions to do:
  - type and invariant, add param, initialize, preserve, already exploited
  - termination argument
  - other tests

- discuss (1 slide)
  - lots of questions come up here ~ 10 minutes


          ;; ----
          ;; structural recursion, with path accumulator

          ;; trivial:   reaches lower right, previously seen position
          ;; reduction: move up, down, left, right if possible
          ;; argument:  maze is finite, so moving will eventually
          ;;            reach trivial case or run out of moves
	  
          ;; path is (listof Pos); positions on this path through data
          (define (solve/p p path)
            (cond [(solved? p) true]
                  [(member p path) false]
                  [else
                   (solve/lop (next-ps p)
                              (cons p path))]))

          (define (solve/lop lop path)
            (cond [(empty? lop) false]
                  [else
                   (local [(define try (solve/p (first lop) path))]
                     (if (not (false? try))
                         try
                         (solve/lop (rest lop) path)))]))


use slides to review what it does do, but then ask what happens at the first join

graph picture

do we want to go this way? how might we stop?

 - requires visited --> requires tail recursive (that order)


          ;; tail recursion, with visited accumulator

          ;; trivial:   reaches lower right, previously seen position
          ;; reduction: move up, down, left, right if possible

	  ;; argument:  maze is finite, so moving will eventually
          ;;            reach trivial case or run out of moves
	  
          ;; p-wl is    (listof Pos); worklist
          ;; visited is (listof Pos); every position ever visited
          (define (solve/p p p-wl visited)
            (cond [(solved? p) true]
                  [(member p visited) (solve/lop p-wl visited)]
                  [else
                   (solve/lop (append (next-ps p) p-wl)
                              (cons p visited))]))

          (define (solve/lop p-wl visited)
            (cond [(empty? p-wl) false]
                  [else
                   (solve/p (first p-wl) (rest p-wl) visited)]))


- discuss/questions

